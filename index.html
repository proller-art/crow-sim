<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Karla">
	<style>
		body {
			margin: 0;
			overflow: hidden;
			background-color: #f0f0f0;
		}
		canvas {
			width: 100vw;
			height: 100vh;
		}     
	</style>
	<title>Proller's Crow Sim</title>
</head>
<body onload="render()">
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
let width = canvas.offsetWidth;
let height = canvas.offsetHeight;
const ctx = canvas.getContext('2d');

// Function called right after user resized its screen
function onResize () {
	// We need to define the dimensions of the canvas to our canvas element
	// Javascript doesn't know the computed dimensions from CSS so we need to do it manually
	width = canvas.offsetWidth;
	height = canvas.offsetHeight;
  
	// If the screen device has a pixel ratio over 1
	// We render the canvas twice bigger to make it sharper (e.g. Retina iPhone)
	if (window.devicePixelRatio > 1) {
		canvas.width = canvas.clientWidth * 2;
		canvas.height = canvas.clientHeight * 2;
		ctx.scale(2, 2);
	} else {
		canvas.width = width;
		canvas.height = height;
	}
}
// Listen to resize events
window.addEventListener('resize', onResize);
// Make sure the canvas size is perfect
onResize();

let PERSPECTIVE = 1000; // The field of view of our 3D scene
let PROJECTION_CENTER_X = width / 2; // x center of the canvas
let PROJECTION_CENTER_Y = height / 2; // y center of the canvas

class Point {
	constructor(x, y, z) {
		this.x = x;
		this.y = y;
		this.z = z;

		this.xOffset = x;
		this.yOffset = y;
		this.zOffset = z;
    
		this.xProjected = 0; // x coordinate on the 2D world
		this.yProjected = 0; // y coordinate on the 2D world
		this.scaleProjected = 0; // Scale of the element on the 2D world (further = smaller)
	}
	// Project our element from its 3D world to the 2D canvas
	project() {
		// The scaleProjected will store the scale of the element based on its distance from the 'camera'
		this.scaleProjected = PERSPECTIVE / (PERSPECTIVE + this.z);
		// The xProjected is the x position on the 2D world
		this.xProjected = (this.x * this.scaleProjected) + PROJECTION_CENTER_X;
		// The yProjected is the y position on the 2D world
		this.yProjected = (this.y * this.scaleProjected) + PROJECTION_CENTER_Y;
	}
	// Draw the dot on the canvas
	draw() {
		// We first calculate the projected values of our dot
		this.project();
		// We draw a rectangle based on the projected coordinates and scale
		ctx.beginPath();
		ctx.arc(this.xProjected, this.yProjected, 2 * this.scaleProjected, 0, Math.PI*2);
		ctx.fill();
	}
}

class Line {
	constructor(pointA, pointB) {
		this.pointA = pointA;
		this.pointB = pointB;
	}

	draw() {
		this.pointA.project();
		this.pointB.project();
		ctx.beginPath();
		ctx.moveTo(this.pointA.xProjected, this.pointA.yProjected);
		ctx.lineTo(this.pointB.xProjected, this.pointB.yProjected);
		ctx.stroke();
	}
}

class Polygon {
	constructor(points) {
		this.points = points; //array of points
	}
	// Draw the polygon with option of wireframe (solid if false)
	draw(wireframe) {
		if (this.points.length < 1) {
			return;
		}
		this.points[0].project();
		ctx.beginPath();
		ctx.moveTo(this.points[0].xProjected, this.points[0].yProjected);
		for (var i = 1; i < this.points.length; i++) {
			this.points[i].project();
			ctx.lineTo(this.points[i].xProjected, this.points[i].yProjected);
		}
		ctx.lineTo(this.points[0].xProjected, this.points[0].yProjected);
		if (wireframe) {
			ctx.stroke();
		} else {
			ctx.fill();
		}
	}
}

// TO DO: figure out how to parent the origin to a moving point on another solid
class Solid {
	constructor(polygons, origin, scale, parent) {
		this.polygons = polygons; //array of polygons relative to origin
		this.origin = origin; //point
		this.scale = scale;
		this.rotation = [0, 0, 0];
		this.parent = parent;
	}


	// draw the solid at its origin and rotated according to angles
	draw(wireframe) {
		for (var i = 0; i < this.polygons.length; i++) {
			// duplicate current polygon at new scale
			let drawnPoints = [];
			for (var j = 0; j < this.polygons[i].points.length; j++) {
				drawnPoints.push(new Point(this.polygons[i].points[j].x * this.scale, this.polygons[i].points[j].y * this.scale, this.polygons[i].points[j].z * this.scale));
			}
			let drawnPolygon = new Polygon(drawnPoints);

			// rotate using origin as axis
			// z-axis
			if (this.parent) {
				var sinTheta = Math.sin(this.rotation[2] + this.parent.rotation[2]);
				var cosTheta = Math.cos(this.rotation[2] + this.parent.rotation[2]);
			} else {
				var sinTheta = Math.sin(this.rotation[2]);
				var cosTheta = Math.cos(this.rotation[2]);
			}
			for (var j = 0; j < drawnPolygon.points.length; j++) {
				var points = drawnPolygon.points;
				var x = points[j].x;
				var y = points[j].y;
				points[j].x = x * cosTheta - y * sinTheta;
				points[j].y = y * cosTheta + x * sinTheta;
			}

			// x-axis
			if (this.parent) {
				var sinTheta = Math.sin(this.rotation[0] + this.parent.rotation[0]);
				var cosTheta = Math.cos(this.rotation[0] + this.parent.rotation[0]);
			} else {
				sinTheta = Math.sin(this.rotation[0]);
				cosTheta = Math.cos(this.rotation[0]);
			}
			for (var j = 0; j < drawnPolygon.points.length; j++) {
				var points = drawnPolygon.points;
				var y = points[j].y;
				var z = points[j].z;
				points[j].y = y * cosTheta - z * sinTheta;
				points[j].z = z * cosTheta + y * sinTheta;
			}

			// y-axis
			if (this.parent) {
				var sinTheta = Math.sin(this.rotation[1] + this.parent.rotation[1]);
				var cosTheta = Math.cos(this.rotation[1] + this.parent.rotation[1]);
			} else {
				sinTheta = Math.sin(this.rotation[1]);
				cosTheta = Math.cos(this.rotation[1]);
			}
			for (var j = 0; j < drawnPolygon.points.length; j++) {
				var points = drawnPolygon.points;
				var x = points[j].x;
				var z = points[j].z;
				points[j].x = x * cosTheta + z * sinTheta;
				points[j].z = z * cosTheta - x * sinTheta;
			}
			

			// update position to fit origin
			if (this.parent) {
				for (var j = 0; j < drawnPolygon.points.length; j++) {
					drawnPolygon.points[j].x += this.origin.x + this.parent.origin.x;
					drawnPolygon.points[j].y += this.origin.y + this.parent.origin.y;
					drawnPolygon.points[j].z += this.origin.z + this.parent.origin.z;
				}
			} else {
				for (var j = 0; j < drawnPolygon.points.length; j++) {
					drawnPolygon.points[j].x += this.origin.x;
					drawnPolygon.points[j].y += this.origin.y;
					drawnPolygon.points[j].z += this.origin.z;
				}
			}
			

			


			// draw the polygon
			drawnPolygon.draw(wireframe);
		}
	}
}

// Create Polygons
const cubePoints = [];
cubePoints.push(new Point(-50, -50, -50));
cubePoints.push(new Point(-50, -50, 50));
cubePoints.push(new Point(50, -50, -50));
cubePoints.push(new Point(50, -50, 50));
cubePoints.push(new Point(-50, 50, -50));
cubePoints.push(new Point(-50, 50, 50));
cubePoints.push(new Point(50, 50, -50));
cubePoints.push(new Point(50, 50, 50));

/*cubePoints.push(new Point(0, 0, 0));
cubePoints.push(new Point(0, 0, 100));
cubePoints.push(new Point(100, 0, 0));
cubePoints.push(new Point(100, 0, 100));
cubePoints.push(new Point(0, 100, 0));
cubePoints.push(new Point(0, 100, 100));
cubePoints.push(new Point(100, 100, 0));
cubePoints.push(new Point(100, 100, 100));*/

const polyCube = [];
polyCube.push(new Polygon([cubePoints[0], cubePoints[1], cubePoints[3], cubePoints[2]]));
polyCube.push(new Polygon([cubePoints[4], cubePoints[5], cubePoints[7], cubePoints[6]]));
polyCube.push(new Polygon([cubePoints[0], cubePoints[2], cubePoints[6], cubePoints[4]]));
polyCube.push(new Polygon([cubePoints[1], cubePoints[0], cubePoints[4], cubePoints[5]]));
polyCube.push(new Polygon([cubePoints[3], cubePoints[1], cubePoints[5], cubePoints[7]]));
polyCube.push(new Polygon([cubePoints[2], cubePoints[3], cubePoints[7], cubePoints[6]]));

const cube = new Solid(polyCube, new Point(0, 0, 0), .5);
const cube2 = new Solid(polyCube, new Point(0, 0, 0), 1.2, cube);
const cube3 = new Solid(polyCube, new Point(0, 0, 0), 2.2);

let timer = 0;
function render() {
	// Clear the scene from top left to bottom right
	ctx.clearRect(0, 0, width, height);

	cube.origin = new Point(0, Math.sin(timer/50)*50, 0);
	cube3.origin = new Point(0, Math.sin(timer/50)*50, 0);

	cube.rotation = [timer/20, timer/20, timer/20];
	cube2.rotation = [-timer/10, -timer/10, -timer/10];
	cube3.rotation = [timer/500, timer/500, timer/500];
	cube.draw(true);
	cube2.draw(true);
	cube3.draw(true);
	timer++;
  
	// Request the browser the call render once its ready for a new frame
	window.requestAnimationFrame(render);
}

</script>
</body>
</html>
